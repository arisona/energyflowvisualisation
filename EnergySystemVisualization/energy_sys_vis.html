<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>first Example</title>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="sankey.js"></script>
    <script type="text/javascript" src="d3.slider.js"></script>
    <script type="text/javascript" src="dataQueries.js"></script>
    <script type="text/javascript" src="jquery-2.1.3.min.js"></script>
    <script type="text/javascript" src="jquery-migrate-1.2.1.min.js"></script>
    <script type="text/javascript" src="gridster.js"></script>
    <style>
        @import url(styles/styles.css);
        @import url(styles/d3.slider.css);
        @import url(styles/jquery.gridster.min.css);

        body {
            font-family: Verdana,Arial,sans-serif;
        }

        #slider {
            margin-left: 20px;
            margin-right: 20px;
        }

        rect.node {
            stroke-width: 1px;
            stroke: black;
        }

        rect.energytype {
            stroke-width: 0;
            fill-opacity: .5;
        }

        .diagram {
            background: #efefef;
        }

        header.drag-handle {
            height: 20px;
            background: deeppink;
        }
    </style>
</head>
<body>

<div class="gridster">
        <!--<div data-row="1" data-col="1" data-sizex="1" data-sizey="1" class="diagram" >-->
            <!--<header class="drag-handle"></header>-->
                <!--<svg id="chart"></svg>-->
                <!--<div id="slider"></div>-->
        <!--</div>-->
</div>

<script type="text/javascript" id="code">
    // Monitor state of mouse buttons. For usage in displays on hovering over a certain element, which i wanted to
    // prevent from happening if a mouse button is pressed.
    var mouseDown = 0;
    document.body.onmousedown = function() { ++mouseDown; };
    document.body.onmouseup = function() { --mouseDown; };

    core = function() {
        var core = {};
        var maxCols = 2;
        var maxRows = 2;
        var maxDiagrams = maxCols * maxRows;
        var nrOfDiagrams = 0;
        var minNodeWidth = 10;
        var minWidgetWidth = 700;
        var headerHeight = 20; // XXX statically defined in css class 'header.drag-handle'.
        var sliderHeight = 100;
        var widgetMargin = 30;
        var widgetWidth = (window.innerWidth / maxDiagrams) - (widgetMargin * (maxCols + 1));
        if (widgetWidth < minWidgetWidth) widgetWidth = minWidgetWidth;
        var widgetHeight = window.innerHeight - (widgetMargin * (maxRows + 1));
        var diagramWidth = widgetWidth;
        var diagramHeight = widgetHeight - headerHeight - sliderHeight;
        var nodeWidth = minNodeWidth * widgetWidth/minWidgetWidth;

        core.nrOfDiagrams = function(_) {
            if (!arguments.length) return nrOfDiagrams;
            nrOfDiagrams = _;
            return core;
        }
        /**
         * the list of diagrams
         */
        var sankeys = {};

        var gridster;
        /**
         * Needs a div element with id 'gridster' in which the grid will be set up.
         */
        core.createGrid = function() {
            gridster = $(".gridster").gridster({
                widget_margins: [widgetMargin, widgetMargin],
                widget_base_dimensions: [widgetWidth, widgetHeight],
                max_cols: maxCols,
                widget_selector: 'div',
                draggable: {
                    handle: 'header'
                },
                resize: {
                    enabled: true,
                    stop: function(e, ui, widget) {
                        diagramWidth = this.resize_coords.data.width;
                        diagramHeight = this.resize_coords.data.height - headerHeight - sliderHeight;
                        // Select the svg element of the resized widget.
                        d3.select(widget[0])
                                .select(".chart")
                                .attr("width", diagramWidth)
                                .attr("height", diagramHeight);

                        var sankey = sankeys[d3.select(widget[0]).attr("id")];
                        sankey.size([diagramWidth, diagramHeight]);
                        sankey.relayout(300);
                        sankey.redrawDiagram();
                    }
                }
            }).data('gridster');
            return core;
        };

        core.createSankey = function() {
            if (nrOfDiagrams < maxDiagrams) {
                var chartId = "chart" + nrOfDiagrams++;
                var newDiv = document.createElement("div");
                var widgetObject = gridster.add_widget(newDiv);
                newDiv = d3.select(newDiv)
                        .attr("id", chartId);
                newDiv.append("header").attr("class", "drag-handle");
                newDiv.append("svg").attr("class", "chart");
                newDiv.append("div").attr("class", "slider");

                var newSankey = d3.sankey()
                        .nodeWidth(nodeWidth)
                        .nodePadding(30)
                        .size([diagramWidth, diagramHeight])
                        .widgetRoot(widgetObject[0]);

                sankeys[chartId] = newSankey;
                newSankey.setUpChart();
                newSankey.createDiagram();
                return core;
            } else {
                alert("can't create more diagrams");
                return core;
            }
        };
        return core;
    };

    var core = core();
    core.createGrid();
//    core.createSankey();

</script>
</body>
</html>

