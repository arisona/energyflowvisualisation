<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>first Example</title>
    <script type="text/javascript" src="d3.min.js"></script>
    <script type="text/javascript" src="sankey.js"></script>
    <style>
        @import url(styles.css);

        #chart {
            height: 500px;
        }

        .node rect {
            cursor: move;
            fill-opacity: .9;
            shape-rendering: crispEdges;
        }

        .node text {
            pointer-events: none;
            text-shadow: 0 1px 0 #fff;
        }

        .link {
            fill: none;
            stroke: #000;
            stroke-opacity: .5;
        }

        .link:hover {
            stroke-opacity: .6;
        }

        .linkborder {
            fill: none;
            stroke: #000;
            stroke-opacity: 1;
            stroke-width: 1;
        }

        #link10, #link20, #link40, #link03, #link029, #link025, #link027 {
            stroke: #5F021F;
        }

        /*TODO more colors for the different kind of links*/

    </style>
</head>
<body>

<h1>Sankey Diagrams</h1>

<div id="buttons"></div>
<p id="chart">
    <!--This is where the diagram is placed-->
</p>

<script>

    var margin = {top: 1, right: 1, bottom: 6, left: 1};
    var width = 960 - margin.left - margin.right;
    var height = 500 - margin.top - margin.bottom;

    var color = d3.scale.category20();

    var svg = d3.select("#chart").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g").attr("id", "sankey")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var sankey = d3.sankey()
            .nodeWidth(40)
            .nodePadding(10)
            .size([width, height]);

    var path = sankey.link();
    var pathborder = sankey.linkborder();
    var pathtext = function(d) {
        var ys = d.source.y + d.sy + d.dy / 2;
        var yt = d.target.y + d.ty + d.dy / 2;
        return (ys + yt) / 2;
    };

    function formatNumber(number) {
        return d3.format(">,d")(number);
    }

    d3.json("data_custom.json", function (error, graph) {
        if (error) console.warn("Error occurred while parsing JSON file" + error);
        var years = [];
        for (var i = 0; i < graph.data.length; i++) {
            years[i] = graph.data[i].year;
        }
        years.forEach(function (year) {
            // Create a button for each year found in the JSON data.
            // The buttons click action searches for the data corresponding to the year and creates the Sankey
            // diagram from that years data.
            d3.select("#buttons").append("button")
                    .attr("width", 200)
                    .attr("height", 50)
                    .attr("name", year)
                    .on("click", function () {
                        for (var i = 0; i < graph.data.length; i++) {
                            if (graph.data[i].year == year) {
                                createSankey(graph.data[i]);
                                break;
                            }
                        }
                    }).html(year);
        });
    });


    function createSankey(graph) {

        // Clear the svg elements
        svg.selectAll(".node").remove();
        svg.selectAll(".link").remove();
        sankey
                .nodes(graph["nodes"])
                .links(graph["links"])
                .layout(32);

        // Each path is set in a group element for easier manipulation possibilities, like hovering.
        // Each path gets an CSS id with consists of the word link followed by the ids of the source and the target.
        var pathGroups = svg.append("g").selectAll(".link")
                .data(graph.links)
                .enter().append("g").attr("class", "group");
        pathGroups
                .append("path")
                .attr("class", "link")
                .attr("id", function (d) {return "link" + d.source.id + d.target.id;})
                .attr("d", path)
                .style("stroke-width", function (d) {return Math.max(1, d.dy);});

        // the text element for showing the value of the flow at the middle of each link.
        pathGroups
                .append("text")
                .attr("x", function (d) {return (d.source.x + d.target.x) / 2;})
                .attr("y", pathtext)
                .attr("text-anchor", "middle")
                .attr("transform", null)
                .attr("dy", ".35em");

        // On hovering over the link: Show the value of the flow and draw a border around the link.
        // If flows have a strong bend the border does not fit the flow anymore :(
        // Maybe use d3.svg.area()
        pathGroups.on("mouseover", function (d) {
            d3.select(this).select("text").text(formatNumber(d.value));
            d3.select(this).append("path")
                    .attr("class", "linkborder")
                    .attr("d", pathborder);
        });

        // On leaving the link: Remove value text and the border.
        pathGroups.on("mouseleave", function (d) {
            d3.select(this).select("text").text(null);
            d3.select(this).selectAll(".linkborder").remove();
        });

        // Dragging behavior of nodes disabled.
        var node = svg.append("g").selectAll(".node")
                .data(graph.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", function (d) {return "translate(" + d.x + "," + d.y + ")";})
//                .call(d3.behavior.drag()
//                        .origin(function (d) { return d; })
//                        .on("dragstart", function () {this.parentNode.appendChild(this);})
//                        .on("drag", dragmove));

        node.append("rect")
                .attr("height", function (d) {return d.dy;})
                .attr("width", sankey.nodeWidth())
                .style("fill", function (d) {return d.color = color(d.name.replace(/ .*/, ""));})
                .style("stroke", function (d) {return d3.rgb(d.color).darker(2);})
                .append("title")
                .text(function (d) {return d.name + "\n" + formatNumber(d.value);});


        function dragmove(d) {
            d3.select(this).attr("transform", "translate(" + d.x + "," +
                    (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ")");
            sankey.relayout();
            pathGroups.select(".link").attr("d", path);
        }


//            node.append("text")
//                    .attr("y", function(d) { return d.dy / 2; })
//                    .attr("dy", ".35em")
//                    .attr("text-anchor", "end")
//                    .attr("transform", null)
//                    .text(function(d) { return d.name; })
//                    .filter(function(d) { return d.x < width / 2; })
//                    .attr("x", sankey.nodeWidth())
//                    .attr("text-anchor", "start");
    }
</script>
</body>
</html>